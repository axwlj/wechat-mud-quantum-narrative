# 微信小游戏MUD量子叙事系统设计

## 架构概览

微信小游戏MUD量子叙事项目采用前后端分离架构，前端基于微信小游戏平台，后端部署在单台腾讯云服务器上。整体架构如下：

```
┌─────────────────┐      WebSocket      ┌─────────────────────────────────┐
│                 │◄────────────────────┤                                 │
│  微信小游戏前端  │                     │                                 │
│                 │────────────────────►│                                 │
└─────────────────┘                     │                                 │
                                        │        Node.js后端服务          │
                                        │     (单台腾讯云服务器)          │
┌─────────────────┐      WebSocket      │                                 │
│                 │◄────────────────────┤                                 │
│  微信小游戏前端  │                     │                                 │
│                 │────────────────────►│                                 │
└─────────────────┘                     └─────────────────────────────────┘
                                                       │
                                                       │
                                                       ▼
                                        ┌─────────────────────────────────┐
                                        │                                 │
                                        │       MongoDB + Redis           │
                                        │                                 │
                                        └─────────────────────────────────┘
```

## 核心模块设计

### 1. 量子叙事引擎模块

量子叙事引擎是游戏的核心，负责生成和管理游戏中的事件和剧情。

#### 主要组件：
- **事件量子态管理器**：管理事件的量子态，包括事件的可能状态和概率
- **马尔可夫链处理器**：处理事件之间的转换概率
- **三层处理系统**：
  - 道德抉择层：处理玩家的道德选择
  - 环境变量层：处理游戏环境对事件的影响
  - 时间压力层：处理时间因素对事件的影响
- **观测者系统**：处理玩家观测对事件状态的影响

#### 简化策略：
- 减少事件状态数量，简化状态转换逻辑
- 使用预定义的事件模板，减少动态生成的复杂度
- 将部分复杂计算转移到离线处理，减轻实时计算负担

### 2. 玩家系统模块

玩家系统负责管理玩家的状态、属性和交互。

#### 主要组件：
- **玩家状态管理器**：管理玩家的基本状态和属性
- **角色系统**：管理玩家的社会角色和权限
- **组队系统**：管理玩家之间的组队和互动
- **羁绊系统**：计算和管理玩家之间的羁绊值

#### 简化策略：
- 初期限制同时在线玩家数量，减轻服务器负担
- 简化角色系统，初期只实现核心角色类型
- 将复杂的玩家关系计算批处理化，非实时更新

### 3. 世界系统模块

世界系统负责管理游戏世界的状态和演变。

#### 主要组件：
- **地图管理器**：管理游戏世界的地理结构
- **NPC系统**：管理非玩家角色
- **文明演进系统**：管理游戏世界的文明发展
- **资源系统**：管理游戏世界的资源分布和变化

#### 简化策略：
- 使用分区加载技术，只加载玩家周围的世界区域
- 简化NPC行为逻辑，减少实时计算
- 文明演进系统采用阶段性更新，而非实时计算

### 4. 通信模块

通信模块负责前后端之间的数据交换。

#### 主要组件：
- **WebSocket管理器**：管理WebSocket连接
- **消息处理器**：处理前后端之间的消息
- **命令解析器**：解析玩家输入的命令
- **状态同步器**：同步游戏状态到前端

#### 优化策略：
- 使用二进制协议减少数据传输量
- 实现消息压缩和批处理
- 优化状态同步策略，减少不必要的数据传输

## 数据模型设计

### 1. 玩家数据模型

```javascript
{
  _id: ObjectId,           // 玩家唯一ID
  wxOpenId: String,        // 微信OpenID
  nickname: String,        // 玩家昵称
  role: String,           // 社会角色
  attributes: {           // 玩家属性
    strength: Number,     // 力量
    intelligence: Number, // 智力
    charisma: Number      // 魅力
  },
  inventory: [            // 物品栏
    {
      itemId: ObjectId,   // 物品ID
      quantity: Number    // 数量
    }
  ],
  position: {             // 位置
    mapId: String,        // 地图ID
    x: Number,            // X坐标
    y: Number             // Y坐标
  },
  relationships: [        // 社交关系
    {
      playerId: ObjectId, // 关系玩家ID
      bondValue: Number,  // 羁绊值
      type: String        // 关系类型
    }
  ],
  questLog: [             // 任务日志
    {
      questId: ObjectId,  // 任务ID
      status: String,     // 任务状态
      progress: Number    // 任务进度
    }
  ],
  lastLogin: Date,        // 最后登录时间
  createdAt: Date         // 创建时间
}
```

### 2. 事件数据模型

```javascript
{
  _id: ObjectId,           // 事件唯一ID
  type: String,            // 事件类型
  title: String,           // 事件标题
  description: String,     // 事件描述
  quantumStates: [         // 量子态
    {
      stateId: String,     // 状态ID
      probability: Number, // 概率
      description: String, // 状态描述
      outcomes: [          // 可能结果
        {
          outcomeId: String, // 结果ID
          description: String, // 结果描述
          effects: [        // 效果
            {
              type: String, // 效果类型
              target: String, // 效果目标
              value: Mixed   // 效果值
            }
          ]
        }
      ]
    }
  ],
  triggers: [              // 触发条件
    {
      type: String,        // 条件类型
      value: Mixed         // 条件值
    }
  ],
  observers: [ObjectId],   // 观测者列表
  status: String,          // 事件状态
  createdAt: Date,         // 创建时间
  resolvedAt: Date         // 解决时间
}
```

### 3. 世界数据模型

```javascript
{
  _id: ObjectId,           // 世界唯一ID
  name: String,            // 世界名称
  civilizationLevel: Number, // 文明等级
  maps: [                  // 地图列表
    {
      mapId: String,       // 地图ID
      name: String,        // 地图名称
      width: Number,       // 地图宽度
      height: Number,      // 地图高度
      tiles: [             // 地图瓦片
        {
          x: Number,       // X坐标
          y: Number,       // Y坐标
          type: String,    // 瓦片类型
          objects: [       // 瓦片上的对象
            {
              type: String, // 对象类型
              id: ObjectId  // 对象ID
            }
          ]
        }
      ]
    }
  ],
  npcs: [                  // NPC列表
    {
      npcId: ObjectId,     // NPC ID
      name: String,        // NPC名称
      role: String,        // NPC角色
      position: {          // NPC位置
        mapId: String,     // 地图ID
        x: Number,         // X坐标
        y: Number          // Y坐标
      },
      quantumState: Boolean // 是否处于量子态
    }
  ],
  resources: [             // 资源列表
    {
      resourceId: String,  // 资源ID
      name: String,        // 资源名称
      amount: Number,      // 资源数量
      distribution: [      // 资源分布
        {
          mapId: String,   // 地图ID
          x: Number,       // X坐标
          y: Number,       // Y坐标
          amount: Number   // 数量
        }
      ]
    }
  ],
  techTree: {              // 科技树
    unlockedTechs: [String], // 已解锁科技
    currentResearch: {     // 当前研究
      techId: String,      // 科技ID
      progress: Number     // 研究进度
    }
  },
  globalEvents: [ObjectId], // 全局事件列表
  lastUpdated: Date        // 最后更新时间
}
```

## 微信小游戏平台限制与解决方案

### 1. 代码包大小限制

**限制**：微信小游戏基础代码包限制为4MB，分包后总计不超过20MB。

**解决方案**：
- 采用分包加载，将游戏资源和非核心代码放入分包
- 使用代码压缩和混淆工具减小代码体积
- 使用云存储存放大型资源文件，动态加载
- 优化文本资源，使用压缩算法存储长文本

### 2. 网络请求限制

**限制**：微信小游戏对网络请求频率和并发连接数有限制。

**解决方案**：
- 优化WebSocket连接，保持单一长连接
- 实现请求合并和批处理机制
- 使用本地缓存减少网络请求
- 实现断线重连和请求重试机制

### 3. 后台运行限制

**限制**：微信小游戏在切入后台后，JS线程会被挂起。

**解决方案**：
- 实现游戏状态保存机制，在切入后台时保存状态
- 在恢复前台时重新同步游戏状态
- 使用服务器端状态保持，减少客户端依赖
- 实现优雅的断线处理机制

### 4. 存储限制

**限制**：微信小游戏本地存储限制为10MB。

**解决方案**：
- 优化本地存储数据结构，减少冗余
- 实现数据压缩机制
- 将非关键数据存储在服务器端
- 实现数据清理机制，定期清理过期数据

### 5. 性能限制

**限制**：微信小游戏运行在手机浏览器环境，性能受限。

**解决方案**：
- 优化渲染逻辑，减少不必要的重绘
- 实现资源预加载和缓存机制
- 使用Web Worker处理复杂计算
- 将复杂计算转移到服务器端处理

## 系统交互流程

1. **玩家登录流程**：
   - 玩家打开微信小游戏
   - 前端请求微信登录授权
   - 获取微信OpenID并发送到后端
   - 后端验证身份并返回玩家数据
   - 前端加载游戏界面

2. **命令处理流程**：
   - 玩家输入命令
   - 前端解析命令并通过WebSocket发送到后端
   - 后端处理命令并更新游戏状态
   - 后端将结果返回给前端
   - 前端更新界面显示

3. **事件触发流程**：
   - 系统检测到事件触发条件
   - 后端创建事件并设置初始量子态
   - 后端将事件通知发送给相关玩家
   - 前端显示事件描述和可能的选择
   - 玩家做出选择，导致事件状态坍缩
   - 后端处理事件结果并更新游戏状态

4. **多人交互流程**：
   - 玩家A发起交互请求
   - 后端将请求转发给玩家B
   - 玩家B响应请求
   - 后端处理交互结果并更新双方状态
   - 前端更新双方界面显示